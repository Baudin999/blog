---
layout: post
title: Luanti 
author: Carlos Kelkboom
date: 2025-03-23
published: true
tags: Software Development, Gaming
---

Programmeren me Luanti (Minetest), een leerboek voor programmeurs van 10 tot 12.<br />
(EN) Programming with Luanti (Minetest), in Dutch

# Programmeren met Luanti (Minetest) – Leerboek voor jonge programmeurs (10-12 jaar)

*Welkom bij het leerboek **Programmeren met Luanti**! Luanti (voorheen bekend als Minetest) is een open source bouw- en ontdekspel, net als Minecraft, maar waarin je ook zelf nieuwe dingen kunt toevoegen via **mods**. In dit boek ga je stap voor stap leren hoe je zulke mods kunt maken. We doen dit met leuke, eenvoudige voorbeelden. We gaan bijvoorbeeld een mod maken om van modder een diamant te craften, toverdrankjes brouwen om te vliegen of langzaam neer te dalen, speciale armor maken die je krachten geeft, gekke zwaarden creëren en zelfs je eigen statistiek op het scherm tonen. Tot slot leer je hoe je jouw mods samen met vriend(inn)en op een lokaal netwerk kunt spelen. Je hoeft Lua (de programmeertaal van Luanti) niet van tevoren te kennen – je leert al doende door de code over te typen, uit te proberen en aan te passen. We leggen alles vriendelijk en duidelijk uit. Veel plezier en succes!*

---

## Hoofdstuk 1: Wat is een mod?

**Wat ga je leren?** In dit hoofdstuk leer je wat een *mod* is en hoe je er zelf een kunt maken. We laten de basisstructuur van een mod zien en schrijven een heel eenvoudige eerste mod. Je leert waar je de bestanden neerzet en hoe je de mod in het spel kunt testen. We eindigen met een paar kleine experimentjes om zelf uit te proberen.

### Wat is een mod?

Een **mod** (afkorting van *modificatie*) is een aanvulling op het spel die door spelers zelf gemaakt is. In Luanti/Minetest kun je met mods bijna alles in het spel aanpassen of uitbreiden: nieuwe blokken en items toevoegen, recepten verzinnen, het gedrag van de speler veranderen, noem maar op. Mods worden geschreven in de programmeertaal **Lua**. Gelukkig is Lua eenvoudig en hoef je niet alles ervan te kennen om met mods te beginnen. We gaan je door voorbeelden laten zien hoe het werkt. 

Stel je een mod voor als een **map** (folder) met daarin bestanden die de code en andere data (zoals plaatjes voor nieuwe items) bevatten. Als je Luanti opstart en je mod inschakelt, zal het spel jouw Lua-code uitvoeren en zo de veranderingen in het spel laden.

### De structuur van een mod

Een mod heeft minimaal twee dingen nodig:
- Een **map** met de naam van je mod. Bijvoorbeeld: `welkom_mod`. (Kies een duidelijke naam zonder spaties. Deze naam wordt de modnaam.)
- In die map een bestand **`init.lua`**. Hierin komt de Lua-code van je mod. Luanti voert dit automatisch uit wanneer de mod geladen wordt.
- (Optioneel) een bestand **`mod.conf`** voor informatie over je mod, zoals de naam en afhankelijkheden.

Je kunt meerdere bestanden en submappen hebben (bijv. een `textures` map voor afbeeldingen), maar `init.lua` is altijd het startpunt.

**Voorbeeld bestandsstructuur van een simpele mod:**

```plaintext
welkom_mod/         <- Dit is de mod map (naam van de mod)
├── init.lua        <- Hier komt de Lua-code
└── mod.conf        <- Info over de mod (naam, afhankelijkheden, etc.)
```

In `mod.conf` zetten we meestal ten minste de naam van de mod. Bijvoorbeeld:  
```
name = welkom_mod
```

### Onze eerste mod: een welkomstbericht

Laten we een hele simpele mod maken die een bericht in de chat laat zien zodra je de wereld betreedt. Zo kun je meteen testen of je mod werkt.

Open Visual Studio Code (VSCode) en maak de map voor je mod (bijv. `welkom_mod`). Maak daarin de bestanden `mod.conf` en `init.lua`. Vul `mod.conf` zoals hierboven (met `name = welkom_mod`). Schrijf daarna de volgende code in `init.lua`:

```lua
-- Stuur een welkomstbericht naar iedere speler die het spel betreedt
minetest.register_on_joinplayer(function(player)
    local naam = player:get_player_name()              -- De gebruikersnaam van de speler
    minetest.chat_send_player(naam, "Welkom " .. naam .. " in Luanti!")  -- Stuur bericht
end)
```

Zo, dat is je eerste stukje mod-code! Laten we even kort doornemen wat het doet:
- `minetest.register_on_joinplayer(...)` registreert een functie die wordt aangeroepen telkens als een speler de wereld binnenkomt. In ons geval hebben we een anonieme functie `function(player) ... end` die een bericht stuurt.
- `player:get_player_name()` haalt de naam van de speler op die zojuist is verschenen.
- `minetest.chat_send_player(naam, "Welkom ...")` stuurt een chatbericht naar die speler. We plakken met `..` de spelersnaam achter het woord "Welkom ".

Je hoeft dit nu nog niet allemaal te begrijpen – belangrijker is dat je ziet *wat* het doet. Kopieer de code precies over en sla het bestand op.

### Testen in Minetest

Nu gaan we je mod uitproberen in het spel. Volg deze stappen:

1. **Plaats de mod in de mods-folder:** Zorg dat de map `welkom_mod` in de `mods` directory van Minetest/Luanti staat. (Als je Minetest Game speelt, kun je de mod ook in de `mods` map van die game zetten.) Dit heb je waarschijnlijk al gedaan toen je de map aanmaakte.
2. **Activeer de mod:** Start Luanti en ga naar *Start Game* (Een nieuw spel beginnen of een wereld selecteren). Kies de wereld waarin je wilt testen (of maak een nieuwe wereld). Klik op *Configure* of *Select Mods* voor die wereld en zorg dat jouw mod `welkom_mod` aangevinkt is. Start dan de wereld.
3. **Bekijk het resultaat:** Wanneer je wereld geladen is, zou er in de chat links onderin een bericht moeten staan, bijvoorbeeld: “Welkom speler1 in Luanti!” (als jouw spelernaam speler1 is). 

Als je dit bericht ziet, is je mod succesvol geladen en uitgevoerd! Gefeliciteerd, je hebt je eerste mod gemaakt 🎉.

*Krijg je geen bericht te zien?* Controleer of je de mod geactiveerd hebt voor de wereld. Als dat zo is, sluit Minetest en kijk of er foutmeldingen in de terminal of debug.txt staan – misschien staat er een typefout in je code. Je kunt ook proberen via de chat de opdracht `/mods` te typen; het spel laat dan zien welke mods actief zijn in de wereld. Staat jouw mod ertussen?

### Verwijzing naar documentatie

Wil je meer weten over dit soort basisfuncties? Je kunt in de officiële documentatie zoeken naar termen als **`register_on_joinplayer`** en **`chat_send_player`** (zoek bijvoorbeeld op *Minetest modding API on_joinplayer*). Daar vind je uitleg over alle functies die je kunt gebruiken.

### Oefeningen

Probeer nu zelf het volgende om nog meer te leren:

1. **Bericht aanpassen:** Pas de tekst van het welkomstbericht aan. Laat bijvoorbeeld een andere groet zien of voeg iets toe, zoals “Veel plezier!” achter de naam. Start het spel opnieuw en zie of het werkt.
2. **Extra bericht na een tijdje:** Kun jij de mod zo aanpassen dat hij niet alleen meteen begroet, maar bijvoorbeeld 5 seconden later nóg een bericht stuurt? (Tip: Zoek in de API documentatie naar iets als *“Minetest after delay”* of kijk of er een functie bestaat zoals `minetest.after` waarmee je code na een paar seconden kunt laten uitvoeren.)
3. **Eigen idee:** Bedenk een andere eenvoudige actie die gebeurt als je de wereld start. Bijvoorbeeld een geluid afspelen of een item geven. Probeer het uit door in de API te zoeken (bijv. zoek op *“Minetest give item to player”* voor het geven van een item). Experimenteer gerust – zo leer je het beste!

Als je deze oefeningen doet, begin je al echt te programmeren. Wees niet bang om iets fout te doen; als er een fout is, geeft het spel dat meestal aan. Pas de code aan en probeer opnieuw. **Goed gedaan tot nu toe!** In het volgende hoofdstuk gaan we een stapje verder en iets tastbaars toevoegen aan het spel: we maken een eigen craft-recept.

---

## Hoofdstuk 2: Een simpele crafting-mod (2× dirt = 1 diamant)

**Wat ga je leren?** In dit hoofdstuk leer je hoe je een eigen crafting-recept toevoegt aan het spel. We maken een mod waardoor je van 2 blokken dirt (modder) een diamant kunt maken. Hiermee leer je hoe je items en recepten registreert. We laten de modstructuur zien en natuurlijk de code die je kunt overnemen. Daarna testen we het recept in het spel. Ten slotte geven we je wat oefenideeën, zoals het maken van je eigen recepten.

### Modstructuur voor het crafting-recept

Maak een nieuwe mod map voor dit project, bijvoorbeeld `dirt_to_diamond`. Deze mod zal één Lua-script bevatten (init.lua) en een mod.conf. In mod.conf zetten we de mod-naam en geven we aan dat we het standaard spel (`default` items) gaan gebruiken:

```plaintext
dirt_to_diamond/
├── init.lua
└── mod.conf
```

In `mod.conf` schrijf je bijvoorbeeld:
```ini
name = dirt_to_diamond
depends = default
```
We zetten `depends = default` om zeker te zijn dat de standaard items (zoals dirt en diamant) geladen zijn voordat onze mod geladen wordt.

### Code: een craft-recept registreren

Open `init.lua` in je `dirt_to_diamond` folder en typ de volgende code over:

```lua
-- Registreer een nieuw craft-recept: 2x dirt -> 1x diamond
minetest.register_craft({
    output = "default:diamond",        -- Wat krijg je (1 diamant uit de default mod)
    recipe = {
        {"default:dirt", "default:dirt"}   -- Wat stop je erin: 2 dirt naast elkaar
    }
})
```

Laten we dit begrijpen:
- `minetest.register_craft({...})` voegt een recept toe. We geven het in een tabel met eigenschappen.
- `output = "default:diamond"` betekent dat het resultaat van het recept één standaard diamant is. (In Minetest worden items vaak aangeduid als `modnaam:itemnaam`. Diamant zit in de `default` mod en heet `diamond`, dus samen `default:diamond`.)
- `recipe = { {"default:dirt", "default:dirt"} }` beschrijft de vorm van de ingrediënten. Hier gebruiken we een 2D-array die de crafting grid voorstelt. We hebben één rij met twee kolommen opgegeven: twee keer `default:dirt` naast elkaar. Dat betekent dat je in het 3×3 crafting veld twee dirt-blokken naast elkaar moet plaatsen (in dezelfde rij) om het recept te laten kloppen. De rest van de plekken mogen leeg zijn.

> **Tip:** Je kunt ook *shapeless* recepten maken (waarbij de positie niet uitmaakt). Dan zou je `type = "shapeless"` toevoegen en de ingrediënten in een enkelvoudige lijst zetten. Maar in dit voorbeeld houden we het bij een vormgebonden recept.

### Testen in Minetest

1. **Mod installeren:** Zorg dat de folder `dirt_to_diamond` (met init.lua en mod.conf erin) in de mods map staat. 
2. **Mod activeren:** Start Luanti en activeer de mod voor een testwereld (net zoals je deed in Hoofdstuk 1, via de mod-selectie van de wereld).
3. **Voorwerpen verzamelen:** Omdat we een recept testen, is het leuk om *niet* in creative mode te zijn, zodat je echt moet craften. Maak een nieuwe wereld of gebruik een bestaande survival-wereld. Verzamel of verkrijg 2 blokken dirt (modder). Dirt is overal op de grond, dus hak twee blokken met je hand of een schep.
4. **Crafting uitvoeren:** Open je **crafting menu** (inventaris). Je ziet een 3×3 knutselvak. Plaats in één rij twee dirt-blokken naast elkaar. Bijvoorbeeld: in vakje [1,1] en [1,2] (eerste rij, eerste en tweede kolom). Je zou nu in het resultaatvak een **diamant** moeten zien verschijnen als output. Sleep of klik de diamant naar je inventory.
5. **Controleer het resultaat:** Je hebt nu een diamant gecraft! Probeer hem bijvoorbeeld te plaatsen (in Minetest Game kun je van diamanten een diamond block maken met 9 diamanten, maar dat terzijde) of gewoon bewaren als trofee.

Werkt het niet? Controleer of je de dirt precies naast elkaar hebt gezet in de crafting grid. Het recept is vormvast: twee dirt in dezelfde rij zonder iets tussen. Als je ze onder elkaar zet, krijg je niets (of het verkeerde recept). **Kijk goed** of de mod actief is (typ eventueel `/mods` in de chat om te zien of `dirt_to_diamond` erbij staat). Zorg ook dat je niet in creative mode zit als je wilt ervaren hoe het craften gaat (in creative kun je namelijk direct items pakken, waardoor craften niet nodig is – je ziet dan misschien niet meteen dat het recept werkt, behalve via een crafting guide mod).

### Verwijzing naar documentatie

Meer weten over het registreren van items en recepten? Zoek in de officiële Minetest API documentatie naar **“register_craft”** of bekijk de sectie *Nodes, Items, and Crafting* in het Minetest Modding Book. Je zult zien dat je ook meerdere items als output kunt geven, shapeless crafts kunt maken en nog veel meer.

### Oefeningen

Nu jij! Hier zijn wat uitdagingen om mee te spelen:

1. **Ander recept, ander resultaat:** Pas de code aan zodat je met 2 dirt iets anders maakt. Bijvoorbeeld 2 dirt -> 1 gouden appel (`default:apple_gold` bestaat in Minetest Game) of 2 dirt -> 5 stenen (`default:stone 5`). Je kunt de output op die manier aanpassen, ook de hoeveelheid door achter de itemnaam een spatie en aantal te zetten.
2. **Nieuwe combinaties:** Voeg een tweede `minetest.register_craft({...})` toe onder de eerste om een extra recept toe te voegen. Bijvoorbeeld een recept om van 1 diamant terug 2 dirt te maken (lekker onlogisch, maar goed voor het oefenen van een *shapeless* recept: hier maakt volgorde niet uit – zoek op hoe je `type = "shapeless"` gebruikt).
3. **Complexere vorm:** Probeer een recept met meer items. Bijvoorbeeld: 3 dirt op een rij laten craften tot een stuk steen, of een L-vorm van dirt laten iets maken. Bedenk iets grappigs en probeer het uit. Zo leer je hoe de recept-array patronen vormt. (Hint: Lege plekken geef je aan met `""` in de recipe matrix.)
4. **Bonus – eigen blok registreren:** Als je durft, kun je vooruit kijken naar hoe je zelf een *nieuw item of blok* maakt en daar een recept voor registreren. (Dat komt in latere hoofdstukken ook aan bod.) Bijvoorbeeld: zoek op *“minetest.register_node”* of *“minetest.register_craftitem”* in de documentatie en experimenteer.

Je bent goed op weg! Mods maken met recepten is een leuke manier om het spel te veranderen. In het volgende hoofdstuk gaan we een stap verder en voegen we echt **nieuwe items** toe aan het spel: magische drankjes waarmee je kunt vliegen. Klaar voor wat tovenarij?

---

## Hoofdstuk 3: Een vliegendrank (potion) maken

**Wat ga je leren?** In dit hoofdstuk maken we een simpele mod die een nieuwe **toverdrank** toevoegt. Wanneer de speler deze “vliegen”-potion drinkt (gebruikt), wordt hij/zij omhoog gelanceerd de lucht in! Zo leer je hoe je eigen items (in dit geval een drankje) te registreren met een speciale *actie* wanneer je het gebruikt. We laten de modstructuur zien, inclusief hoe je een eigen texture kunt toevoegen. Daarna leer je hoe je het item in het spel krijgt en test. We verwijzen je ook weer naar relevante documentatie. Tot slot hebben we oefeningen om de potion aan te passen.

### Modstructuur voor de potion

Maak een nieuwe mod map, bijvoorbeeld `fly_potion`. Binnen deze map heb je weer een `init.lua` en `mod.conf` nodig. Als we een custom item met plaatje maken, komt er ook een submap `textures` bij om de afbeelding van de potion in te zetten:

```plaintext
fly_potion/
├── init.lua
├── mod.conf
└── textures/
    └── fly_potion.png   (bijvoorbeeld, het plaatje voor de potion)
```

In `mod.conf` kun je zetten:
```ini
name = fly_potion
depends = default
```
(We zetten hier `depends = default` alleen omdat we mogelijk standaard dingen zoals een apple gebruiken voor crafting. Strikt genomen heb je het niet altijd nodig, maar het kan geen kwaad de default mod te laten voorladen.)

Voor het plaatje `fly_potion.png` kun je zelf iets tekenen (bijvoorbeeld een klein 16x16 pixel flesje in Paint of een pixel-art tool) en in de textures map plaatsen. Zorg dat de bestandsnaam overeenkomt met wat je in de code als `inventory_image` gaat zetten. Als je geen eigen plaatje hebt, kun je ook tijdelijk een al bestaand plaatje refereren (bijvoorbeeld `"default_apple.png"` uit de game) om niet een onbekend item-icoon te krijgen.

### Code: een potion item registreren

Open het bestand `init.lua` van de `fly_potion` mod en schrijf de volgende code:

```lua
-- Registreer een nieuw item: Vliegen-potion
minetest.register_craftitem("fly_potion:fly_potion", {
    description = "Vliegen Drank",                -- Beschrijving in het spel
    inventory_image = "fly_potion.png",           -- Het icoon (zorg dat het plaatje bestaat in textures/)
    on_use = function(itemstack, user, pointed_thing)
        -- Deze functie wordt uitgevoerd als de speler de potion gebruikt (rechtsklikt)
        local player = user            -- 'user' is de speler die het item gebruikte
        if player then
            -- Teleporteer de speler 10 blokken omhoog
            local pos = player:get_pos()
            pos.y = pos.y + 10
            player:set_pos(pos)
            -- Je kunt ook velocity gebruiken voor een zachtere launch: bijv. player:set_velocity({x=0, y=10, z=0})
            -- Voor nu doen we een instant teleport omhoog.
        end
        return itemstack  -- Geef de (onveranderde) itemstack terug (geen verbruik, potion kan opnieuw gebruikt worden)
    end
})
```

Nu hebben we het item zelf geregistreerd. Maar hoe krijgt de speler deze potion? Laten we ook een craftrecept toevoegen, zodat je ‘m in het spel kunt maken. Voeg onder bovenstaande code nog dit toe:

```lua
-- Recept: 2 appels naast elkaar craften geeft 1 vliegen-potion
minetest.register_craft({
    output = "fly_potion:fly_potion",
    recipe = {
        {"default:apple", "default:apple"}   -- twee appels horizontaal
    }
})
```

Laten we de code doornemen:
- `minetest.register_craftitem("fly_potion:fly_potion", { ... })` creëert een nieuw voorwerp in het spel. We geven het een unieke naam “fly_potion:fly_potion” (format `<modname>:<itemname>`). In dit geval is de modnaam en itemnaam toevallig gelijk behalve de dubbele punt, dat mag.
- `description` is de naam die de speler ziet in het spel (bijvoorbeeld in de tooltip of inventory).
- `inventory_image` is het plaatje-icoon. We verwachten dat `fly_potion.png` in de textures map van onze mod staat. **Tip:** Als je geen eigen plaatje hebt gemaakt, kun je tijdelijk `"default_apple.png"` invullen om een appelicoon te gebruiken, of een ander bestaand plaatje. Dan zie je tenminste iets in je inventory.
- `on_use = function(itemstack, user, pointed_thing) ... end` definieert wat er gebeurt als je met rechts op de potion klikt (alsof je hem “drink”). Hierin hebben we toegang tot de `user` (de speler die het gebruikt).
- In de functie pakken we de positie van de speler (`player:get_pos()`), verhogen de y-coördinaat met 10, en zetten de speler op die nieuwe positie met `player:set_pos(pos)`. Effect: de speler wordt 10 blokken de lucht in geteleporteerd, alsof die omhoog schiet.
- We returnen `itemstack` zonder het item te verminderen, zodat de potion niet opraakt. Zo kun je hem steeds opnieuw testen. **Uitdaging:** als je wilt dat de potion verdwijnt na een slok, kun je `itemstack:take_item()` doen vóór je return, om 1 item uit de stack te verwijderen.
- Het craftrecept onderaan zorgt dat je de potion kunt brouwen door twee appels naast elkaar te craften. (In Minetest Game zijn appels te vinden aan bomen. Je kunt ook in creative de appels pakken.)

### Testen in Minetest

1. **Mod activeren:** Zorg dat de `fly_potion` map (met de bestanden en texture) in de mods-folder staat en activeer de mod voor je wereld.
2. **Potion verkrijgen:** Er zijn twee manieren om de potion te krijgen:
   - *Via crafting:* Zoek of pluk 2 appels (of geef ze aan jezelf in creative) en plaats ze naast elkaar op de crafting grid. Je krijgt dan een *Vliegen Drank*. Neem hem in je inventory.
   - *Via creative menu:* Als je in creative mode bent, kun je in de itemlijst zoeken naar “Vliegen Drank” of het icoontje van je potion. Pak het daaruit.
   - *Via chat commando:* Je kunt ook het commando ` /give <jouwnaam> fly_potion:fly_potion ` gebruiken om er eentje te krijgen.
3. **Gebruik de potion:** Houd de potion in je hand (selecteer hem in de hotbar) en klik rechts (alsof je eet/drinkt). Als het goed is, *whoosh!* schiet je ineens een flink stuk omhoog de lucht in. Je hebt de vliegen-potion met succes gebruikt.
4. **Ervaar het effect:** Je zult merken dat je daarna natuurlijk weer omlaag valt. Als je in survival mode zit, pas op: zo’n val kan pijn doen! (Je verliest waarschijnlijk wat hartjes, afhankelijk van hoe hoog je ging.) In creative mode heb je geen val-schade, dus daar merk je geen nadeel.
5. **Herhaal:** Probeer de potion nog eens te gebruiken. Omdat we het item niet laten verdwijnen, kun je hem onbeperkt testen. (In een echt spel zou je hem waarschijnlijk wel laten verbruiken.)

**Problemen?** Zie je de potion niet in het creative menu of lukt het craften niet? Controleer of de mod aan staat en of je geen typefouten hebt (bijvoorbeeld in de modnaam). Als je een onbekend item-icoon (vraagteken blokje) ziet, dan is het plaatje niet gevonden – check of de filenaam exact klopt en in de juiste folder staat. 

Je kunt tijdens het spel ook kijken of er foutmeldingen in de chat komen (Luanti geeft codefouten soms in de chat of in debug.txt). Pas je code aan en probeer opnieuw tot het werkt.

### Verwijzing naar documentatie

Wil je snappen welke functies we hier hebben gebruikt? Kijk eens in de API documentatie naar **`register_craftitem`**, **`on_use`**, **`set_pos`** of **`set_velocity`**. Daar kun je lezen over hoe je items maakt en spelers beweegt. Ook is er officiële documentatie over *Items en crafting* in de Minetest Modding Book (zoek op *Minetest register craftitem* bijvoorbeeld).

### Oefeningen

Probeer nu het volgende om de vliegen-potion verder te verkennen:

1. **Hoe hoog?** Pas in de code de hoogte aan waarop de potion je schiet. Probeer `pos.y = pos.y + 20` of zelfs +50. Merk je het verschil? (Pas wel op voor de landing!)
2. **Verbruik de potion:** Wij lieten de potion niet verdwijnen. Pas de code aan zodat de potion bij gebruik **wel** wordt verbruikt. (*Hint:* gebruik `itemstack:take_item(1)` om één item uit de stack af te halen, en geef dan het gewijzigde `itemstack` terug.)
3. **Veilig landen (uitdaging):** Je hebt gemerkt dat vallen pijn kan doen. Kun je de code uitbreiden zodat de potion, naast je omhoog schieten, misschien ook direct je val verzacht? (Bijvoorbeeld door meteen in creative “fly” mode te zetten of de zwaartekracht tijdelijk te verminderen – al vooruitlopend op het volgende hoofdstuk! Je kunt zoeken naar *“minetest physics override gravity”* voor ideeën.)
4. **Eigen idee:** Verander het effect van de potion. In plaats van omhoog schieten, misschien vooruit schieten? (*Hint:* `player:get_look_dir()` geeft de kijkrichting als vector; je zou de positie in die richting kunnen verplaatsen.) Of geef een tijdelijk vermogen om te vliegen (door de speler de “fly” privilege te geven voor een paar seconden – dit is moeilijker, maar misschien kun je er info over vinden).
5. **Maak een tweede potion:** Als je zin hebt, probeer alvast een tweede drankje te bedenken, bijvoorbeeld eentje die je heel snel maakt of je volledig heelt. Je kunt een nieuwe `register_craftitem` toevoegen voor een ander potion item binnen dezelfde mod.

Goed gedaan! Je hebt nu geleerd hoe je een nieuw item maakt dat de speler kan gebruiken met een speciaal effect. In het volgende hoofdstuk bouwen we hierop voort: we maken een potion die je als een veertje zachtjes laat vallen, zodat je veilig uit de lucht kunt komen zweven na al dat vliegen.

---

## Hoofdstuk 4: Een feather fall potion (langzaam neerzweven)

**Wat ga je leren?** In dit hoofdstuk gaan we een tweede potion maken: een “verenval” drank. Deze potion zorgt ervoor dat je tijdelijk bijna geen zwaartekracht hebt, alsof je een veertje bent. Dat betekent dat als je naar beneden valt, je heel langzaam en zachtjes landt, zonder schade. We bouwen hiermee voort op de vorige les en introduceren een nieuw idee: **tijdelijke effecten** (iets dat na een paar seconden weer stopt). Je leert hier hoe je de zwaartekracht-instelling van de speler verandert en hoe je met een timer (tijdvertraging) de normale toestand herstelt.

### Modstructuur

We kunnen deze mod apart maken, bijvoorbeeld in een map `feather_fall`. (Je kunt er ook voor kiezen om hem bij de vorige mod in te voegen, maar voor de leerzaamheid doen we alsof het losse mods zijn.) De structuur lijkt veel op die van de fly_potion:

```plaintext
feather_fall/
├── init.lua
├── mod.conf
└── textures/
    └── feather_fall.png  (icoon voor de potion)
```

In `mod.conf`:
```ini
name = feather_fall
depends = default
```

Maak weer een klein icoon voor deze potion of gebruik tijdelijk een bestaand plaatje. Je zou bijvoorbeeld een afbeelding kunnen kiezen die op een veertje lijkt (of gebruik `"default_cloud.png"` als grapje – alhoewel dat niet echt een veer is). Het belangrijkste is dat de naam in de code straks overeenkomt met je texture-bestand.

### Code: een potion met tijdelijk effect

Open `init.lua` in de `feather_fall` map en typ de volgende code:

```lua
-- Registreer een nieuw item: Feather Fall Drank
minetest.register_craftitem("feather_fall:feather_potion", {
    description = "Veervalveilig Drank",      -- Bijvoorbeeld naam
    inventory_image = "feather_fall.png",
    on_use = function(itemstack, user, pointed_thing)
        local player = user
        if player then
            local name = player:get_player_name()
            -- Verlaag de zwaartekracht voor deze speler
            player:set_physics_override({gravity = 0.2})
            minetest.chat_send_player(name, "Je valt nu heel langzaam als een veertje!")
            -- Na 10 seconden zwaartekracht terugzetten naar normaal (1.0)
            minetest.after(10, function()
                -- Controleer of speler er nog is:
                if player:is_player() then
                    player:set_physics_override({gravity = 1.0})
                    minetest.chat_send_player(name, "De zwaartekracht is weer normaal.")
                end
            end)
        end
        -- Verbruik de potion
        itemstack:take_item(1)
        return itemstack
    end
})
```

En voeg ook een craftrecept toe, zodat we het kunnen maken in het spel:
```lua
-- Recept: 1 appel boven 1 appel (verticaal) geeft een feather fall potion
minetest.register_craft({
    output = "feather_fall:feather_potion",
    recipe = {
        {"default:apple"},
        {"default:apple"}
    }
})
```

Wat gebeurt hier in de code?
- We registreren een item `feather_fall:feather_potion` met een beschrijving en plaatje, vergelijkbaar met vorige potion.
- In `on_use` pakken we de speler en diens naam. We roepen `player:set_physics_override({gravity = 0.2})` aan. Hiermee veranderen we de fysieke eigenschap van de speler: de zwaartekracht wordt op 20% gezet. (Normaal is gravity = 1.0, dit is dus vijf keer lichter, alsof je op de maan bent!)
- Met `minetest.chat_send_player` sturen we een berichtje naar de speler zodat die weet dat het effect actief is.
- Dan gebruiken we `minetest.after(10, function() ... end)` om een functie uit te voeren na 10 seconden. Dit is een handige manier om iets tijdelijk te maken. De anonieme functie binnen `minetest.after` zet na 10 seconden de zwaartekracht van de speler weer terug naar 1.0 (normaal) en stuurt een chatbericht dat het effect is afgelopen.
- We checken `if player:is_player() then ... end` binnen de after-functie om zeker te zijn dat de speler nog bestaat (niet uitgelogd is in die 10s). Dit is een veiligheidscheck.
- Deze keer **verwijderen** we het item na gebruik: `itemstack:take_item(1)` haalt één drankje uit de stapel (effectief dus de potion verdwijnt). We returnen de aangepaste stack zodat de mod weet dat het item op is. Dit is logischer voor een consumptie-item.
- Het craftrecept dat we toevoegen is ditmaal 2 appels verticaal boven elkaar. Dus door in de craftgrid een appel te stapelen op een appel (bijvoorbeeld eentje in [1,1] en eentje in [2,1]) krijg je de feather fall potion. (We hebben expres een andere vorm gekozen dan de vliegdrank, zodat ze niet hetzelfde recept gebruiken.)

### Testen in Minetest

1. **Mod activeren:** Voeg de mod toe en activeer hem voor je testwereld.
2. **Potion bemachtigen:** Weer twee opties:
   - Craft de potion met 2 appels (één boven de ander in de craftgrid). 
   - Of pak hem via creative/`/give` commando (zoek op naam “Veervalveilig Drank” of gebruik `/give naam feather_fall:feather_potion`).
3. **Gebruik de potion:** Zorg dat je op een plek staat waar je wat hoogtes hebt om af te springen (bijv. bouw een pilaar of klim op een heuvel). Activeer de potion (rechterklik). Als het goed is, krijg je een melding “Je valt nu heel langzaam als een veertje!”.
4. **Test het effect:** Spring van een hoogte naar beneden. Je zult merken dat je nu heel traag omlaag zweeft, alsof je superlicht bent! Je landt zacht en hebt waarschijnlijk geen of heel weinig val-schade. Dit komt doordat de zwaartekracht voor jouw speler nu laag is.
5. **Wacht tot afloop:** Wacht 10 seconden (of iets langer). Je krijgt dan bericht dat de zwaartekracht weer normaal is. Als je nu springt, zul je merken dat je weer met normale snelheid valt.

Combineer nu eens met de vorige mod: als je eerst de vliegdrank gebruikt om hoog te komen en dan midden in de lucht de feather fall potion neemt, kun je van grote hoogte springen zonder pijn! Zie je hoe mods gecombineerd kunnen worden voor leuke effecten?

**Let op:** Het effect van de potion geldt alleen voor jouw speler en alleen voor de physics (dus springen, vallen etc.). Als je wordt geslagen of iets dergelijks, krijg je nog steeds normale schade (hier hebben we niets aan veranderd). Ook is 0.2 zwaartekracht nog steeds niet helemaal “geen” zwaartekracht; je valt nog wel, maar langzaam. Je kunt met die waarde spelen.

### Verwijzing naar documentatie

Interessante zoektermen in de API documentatie voor dit hoofdstuk zijn **`set_physics_override`** en **`minetest.after`**. Hiermee kun je van alles doen, zoals snelheid, sprongkracht en zelfs loopgeluid van spelers aanpassen, en met `after` kun je tijdvertragingen inbouwen voor effecten. Zoek bijvoorbeeld eens op *Minetest physics override gravity* of *Minetest after function* om meer te lezen.

### Oefeningen

Nu jij weer aan de slag! 

1. **Effectduur aanpassen:** Verander de 10 seconden naar een andere duur. Misschien 5 seconden, of 20 seconden. Test het in het spel: zweef je merkbaar langer of korter?
2. **Zwaartekracht variëren:** Pas de waarde 0.2 aan. 0.5 zou betekenen half zwaartekracht (je valt dan nog best snel). 0.1 is nóg langzamer vallen. Probeer ook eens 0.0 (dan heb je tijdelijk *geen* zwaartekracht en zweef je omhoog als je sprongkracht nog aan staat!). Let wel dat je dan moeilijk weer op de grond komt totdat het effect stopt.
3. **Meerdere effecten combineren:** Misschien wil je dat de potion niet alleen de zwaartekracht vermindert, maar ook iets anders doet, zoals de loopsnelheid verlagen of juist verhogen (also via `player:set_physics_override({speed = ...})` kun je de snelheid instellen). Voeg zo’n extra effect toe binnen de `on_use` en vergeet niet na de tijd ook terug te zetten.
4. **Geen valsschade (moeilijk):** Een extra uitdaging: in onze simpele aanpak kan het zijn dat hele harde vallen nog steeds wat schade doen. Zou je kunnen uitzoeken hoe je ook val- of andere schade tijdelijk uit kunt zetten? (Hint: Dit is complexer; het heeft met `set_armor_groups` of een “immortal” groep te maken. Je mag dit overslaan, maar misschien vind je iets bruikbaars in de documentatie onder zoekterm *immortal*.)
5. **Nieuwe potion verzinnen:** Maak een derde potion naar eigen fantasie. Bijvoorbeeld een **superspring**-drank (verhoog `jump` in physics_override), of een **snelle Jelle**-drank (verhoog `speed`). Gebruik de code van deze en vorige hoofdstukken als voorbeeld en combineer de ideeën. Bedenk een recept en test je eigen potion in het spel!

Geweldig, je hebt nu twee soorten magische drankjes gemaakt. Hiermee heb je kennis gemaakt met het toevoegen van items, het reageren op gebruik, en het toepassen van tijdelijke veranderingen bij de speler. In de volgende hoofdstukken gaan we andere soorten mods maken, bijvoorbeeld speciale kledij (armor) die je krachten geeft. Ga ervoor!

---

## Hoofdstuk 5: Dirt-armor die licht geeft

**Wat ga je leren?** In dit hoofdstuk duiken we in *armor* (pantser/kledingstukken) en hoe een mod daarmee iets bijzonders kan doen. We maken een simpele helm van dirt die licht geeft in het donker. Het idee: als de speler deze helm “draagt” (in ons geval activeert), dan gaat hij/zij zelf licht uitstralen, zodat donkere grotten verlicht worden. Je leert hier hoe je een item registreert dat niet bedoeld is om te consumeren maar om te dragen/gebruiken voor een permanente werking, en hoe je lichtbronnen in de wereld kunt plaatsen via code. We laten ook een geinige craft zien voor de helm. Aan het eind weer tips om ermee te spelen.

> **Let op:** Minetest Game heeft niet standaard een armor-systeem zoals Minecraft. Er bestaan mods (zoals 3D Armor) die echte draagbare armor toevoegen. In dit voorbeeld doen we het simpel: onze “helm” is eigenlijk een voorwerp dat je in de hand kunt gebruiken om een effect aan/uit te zetten. We simuleren het dragen ervan. Dit houdt het begrijpelijk, al is het niet precies hoe echte armor mods werken.

### Modstructuur

Maak een nieuwe mod folder `dirt_armor`. Hierin komen drie dingen: `init.lua`, `mod.conf` en een textures map met twee plaatjes: één voor het helm-item en één voor de onzichtbare lichtblokjes die we gaan gebruiken.

```plaintext
dirt_armor/
├── init.lua
├── mod.conf
└── textures/
    ├── dirt_helmet.png       (icoon voor de dirt helm)
    └── invisible_light.png   (een eventueel plaatje voor de lichtbron, we maken 'm toch onzichtbaar)
```

In `mod.conf` zetten we:
```ini
name = dirt_armor
depends = default
```

**Textures tekenen:** Voor `dirt_helmet.png` kun je creatief zijn: misschien een 16x16 pixel afbeelding die eruit ziet als een bruin hoedje of helm. Je zou bijvoorbeeld de standaard dirt-textuur kunnen nemen en er een helm-vorm uit knippen. Of als dat lastig is, gebruik een bestaand plaatje als noodoplossing (bijv. `"default_dirt.png"` direct als inventory image, dat zal een blok-icoon tonen).  
Voor `invisible_light.png` is het niet zo belangrijk wat het is, want we gaan de node “air-like” maken (onzichtbaar). Je kunt eventueel een volledig transparant plaatje gebruiken. Of neem `"default_cloud.png"` of zoiets lichts; we zorgen er sowieso voor dat de speler het niet ziet of kan pakken.

### Code: helm en lichtbron registreren

Open `init.lua` in VSCode en typ de volgende code. We gaan twee dingen registreren: eerst een onzichtbaar lichtgevend node, daarna de helm zelf.

```lua
-- Registreer een onzichtbaar lichtgevend node
minetest.register_node("dirt_armor:light_node", {
    description = "Onzichtbaar Licht",
    drawtype = "airlike",          -- Gedraagt zich als lucht (onzichtbaar)
    tiles = {"invisible_light.png"},  -- tekstuur (wordt toch niet getoond door airlike)
    light_source = minetest.LIGHT_MAX,  -- maximale lichtsterkte (14)
    walkable = false,
    pointable = false,
    diggable = false,
    buildable_to = true,
    groups = {not_in_creative_inventory = 1}
})

-- Tabel om bij te houden bij welke spelers de helm-effect aan staat
local helm_active = {}

-- Registreer het dirt helm item
minetest.register_craftitem("dirt_armor:helmet", {
    description = "Dirt Helm (geeft licht)",
    inventory_image = "dirt_helmet.png",
    on_use = function(itemstack, user, pointed_thing)
        local player = user
        if not player or not player:is_player() then
            return itemstack
        end
        local name = player:get_player_name()
        if helm_active[name] then
            -- Als helm al actief is, schakel uit
            helm_active[name] = nil
            minetest.chat_send_player(name, "Je doet de dirt helm af. (Lichteffect uit)")
        else
            -- Helm was niet actief, dus inschakelen
            helm_active[name] = true
            minetest.chat_send_player(name, "Je zet de dirt helm op. (Je straalt nu licht uit!)")
            -- Start een herhalende functie om licht te plaatsen bij de speler
            local function place_light()
                if not helm_active[name] or not player:is_player() then
                    return  -- stop als helm af is of speler weg is
                end
                -- Plaats onzichtbaar licht op de positie van de speler (op hoofdhoogte)
                local pos = player:get_pos()
                pos.y = pos.y + 1
                -- Alleen plaatsen als daar lucht is, om geen blokken te overschrijven
                local node = minetest.get_node(pos)
                if node.name == "air" then
                    minetest.set_node(pos, {name = "dirt_armor:light_node"})
                end
                -- Over 1 seconde opnieuw proberen (zodat het licht 'meebeweegt')
                minetest.after(1, place_light)
            end
            place_light()
        end
        return itemstack
    end
})
```

En nu nog een recept om de helm te craften:

```lua
-- Recept: Dirt helm (in de vorm van een helm in de 3x3 grid)
minetest.register_craft({
    output = "dirt_armor:helmet",
    recipe = {
        {"default:dirt", "default:dirt", "default:dirt"},
        {"default:dirt", "", "default:dirt"},
        {"", "", ""}
    }
})
```

Dit is een hoop code, dus we lopen hem in delen langs:
- **Lichtgevende node:** We registreren `dirt_armor:light_node`. Dit is een blok dat onzichtbaar is (`drawtype = "airlike"` betekent geen model of plaatje in de wereld, net als lucht) en een lichtbron (`light_source = minetest.LIGHT_MAX` – dat is maximale lichtsterkte). We maken hem niet loopbaar en bouwbaar zodat hij zich als lucht gedraagt (je kunt er doorheen lopen en andere blokken kunnen erdoor geplaatst worden). `not_in_creative_inventory = 1` zorgt dat dit blok niet in de lijst verschijnt. Dit blok gaan we straks telkens onder/naast de speler plaatsen om licht te geven.
- **helm_active tabel:** We houden in een Lua-tabel bij of een bepaalde speler de helm-effect aan heeft staan. We gebruiken de spelersnaam als sleutel. Als de helm aan staat, zetten we `helm_active[name] = true`, als uit, halen we die weg (of zetten nil/false).
- **Dirt helm item:** `minetest.register_craftitem("dirt_armor:helmet", { ... })` maakt het helm-item. Het krijgt een plaatje (brown helmet icon) en een `on_use` functie. Deze functie wordt uitgevoerd als de speler met rechts klikt terwijl hij de helm in de hand heeft. (Dit simuleert “opzetten/afzetten” van de helm.)
  - We checken of we een geldige speler hebben. Dan pakken we de naam.
  - Als de helm al actief is (`helm_active[name]`), dan betekent dit dat de speler de helm op heeft en nu af wil zetten. We zetten `helm_active[name]` op nil om uit te schakelen en sturen een chatbericht dat het lichteffect uit gaat.
  - Als de helm niet actief was, zetten we hem nu **aan**: we markeren `helm_active[name] = true` en laten in de chat weten dat de speler nu licht uitstraalt.
  - Vervolgens, als we de helm aandoen, starten we een lokale functie `place_light()` die meteen wordt aangeroepen. Deze functie plaatst een onzichtbaar lichtblok op de positie van de speler’s hoofd (`pos.y + 1`). We controleren of er “air” is op die plek, zodat we niet per ongeluk een echt blok vervangen (stel de speler staat tegen een plafond, dan doen we niets). Dan plaatsen we `dirt_armor:light_node` daar.
  - Heel belangrijk: aan het einde van `place_light()`, roepen we `minetest.after(1, place_light)` om na 1 seconde *dezelfde functie opnieuw* uit te voeren. Hierdoor ontstaat een loop die elke seconde het lichtblok opnieuw plaatst op de huidige positie van de speler. Zo “beweegt” het licht met de speler mee. Deze loop stopt automatisch als `helm_active[name]` niet meer true is (we checken dat aan het begin) of als de speler verdwijnt.
- **Craft recept:** We hebben gekozen voor een helm-vorm: drie dirt in de bovenste rij (voor de bovenkant helm), en in de tweede rij aan de zijkanten dirt (voor de oorbeschermers), met het midden leeg. Dit gebruikt 5 dirt in totaal, net als een helm in Minecraft ook 5 materiaal kost.

### Testen in Minetest

1. **Mod activeren:** Zet de `dirt_armor` mod in je mods folder en activeer hem voor je wereld.
2. **Helm craften:** Verzamel 5 dirt blokken (dat is niet moeilijk 😄) en plaats ze in de crafting table volgens het patroon:
   - Rij 1: [dirt][dirt][dirt]
   - Rij 2: [dirt][leeg][dirt]
   - Rij 3: [leeg][leeg][leeg]
   Je krijgt nu een `Dirt Helm (geeft licht)` item. Neem het uit het craftresultaat.
3. **Helm gebruiken (opzetten):** Ga ergens naartoe waar het donker is, bijvoorbeeld graaf een grot of wacht tot het nacht is in de wereld. Selecteer de dirt helm in je hand en klik met rechts. Je ziet in de chat dat je de helm opzet en nu licht uitstraalt.
4. **Bekijk het lichteffect:** Als het goed is, ben je nu omgeven door licht, alsof je zelf een fakkel bent! Loop rond in het donker: je zou moeten zien dat wherever you go, de omgeving verlicht is. Dit komt door de onzichtbare lichtblokken die de mod steeds plaatst op je positie.
5. **Helm afzetten:** Klik nogmaals met rechts terwijl je de helm vasthebt. Er verschijnt een bericht dat je de helm afdoet en het lichteffect uitgaat. Als je nu wegloopt, zul je merken dat de omgeving niet meer automatisch verlicht wordt (de eerder geplaatste lichtblokjes blijven wel hangen waar ze waren op het moment van uitdoen, omdat we ze niet hebben weggehaald).
6. **Controleer de onzichtbare blokken:** Als je goed kijkt (met de cursor op de plek waar je stond), zie je misschien niks omdat we ze onzichtbaar en niet aanklikbaar hebben gemaakt. Je kunt eventueel een ander blok plaatsen waar je stond om de lichtblok te vervangen/verwijderen (omdat we `buildable_to = true` hebben ingesteld, kun je eroverheen bouwen, dat wist het lichtblok). Maar je zult normaal niet merken waar de lichtblokjes staan.

**Kanttekeningen:** Onze aanpak is simpel en laat een “lichtspoor” achter. Echte mods zouden bij het verplaatsen oude lichtblokjes weghalen of een ander systeem gebruiken. Maar dat is ingewikkelder. Voor ons doel – laten zien dat je met code licht kunt creëren – werkt dit prima. Als je je stoort aan de onzichtbare lichtblokjes die achterblijven, kun je ze opruimen door bijvoorbeeld met een pickaxe in de lucht te slaan waar ze ongeveer zijn (als je raakt, breek je ze misschien, maar omdat pointable=false is dit lastig) of door andere nodes te plaatsen op die plekken.

### Verwijzing naar documentatie

Dit voorbeeld combineert meerdere aspecten: **`register_node`** (voor de lichtbron), **`register_craftitem`** met `on_use` (voor de helm), en het gebruik van **`minetest.after`** voor herhaling. Zoek in de API vooral eens naar `minetest.set_node` (om te begrijpen hoe we nodes plaatsen/vervangen in de wereld) en naar voorbeelden van globalstep of loop voor continu effect. Het concept van de `after` die zichzelf weer aanroept is een manier om een soort loop te maken. In documentatie-termen zou je ook kunnen zoeken op *“Minetest dynamic light”* om te zien hoe anderen lopende licht hebben aangepakt.

### Oefeningen

Probeer weer wat variaties om het nog beter te begrijpen:

1. **Lichtsterkte aanpassen:** In `register_node` hebben we `light_source = minetest.LIGHT_MAX` gebruikt (dat is 14, de max). Je kunt in plaats daarvan bijvoorbeeld 10 of 7 zetten om een zwakker licht te geven. Test het in het spel (donkere omgeving) en kijk hoeveel verschil het maakt.
2. **Interval veranderen:** We plaatsen elke seconde (`minetest.after(1, ...)`). Als je dit sneller doet (bijv. 0.2 seconden), zal het licht waarschijnlijk vloeiender meebewegen, maar dat is wellicht overkill. Probeer eens 2 seconden: je krijgt dan merkbaar vertraagde lichtvolging (je loopt iets voor het licht uit). Experimenteer met de timing.
3. **Lichtspoor opruimen (uitdaging):** Denk na over hoe je de achtergebleven lichtblokjes zou kunnen verwijderen als de helm wordt afgezet. (Hint: je zou de posities kunnen bijhouden in een lijst telkens als je er een plaatst, en als je helm_active false wordt, die posities doorlopen en de blokjes vervangen door lucht. Dit is best gevorderd, dus alleen doen als je meer wilt programmeren.)
4. **Andere armor-effecten:** Nu je weet hoe dit werkt, kun je een vergelijkbare mod maken voor andere grappige effecten. Bijvoorbeeld een **“mijnwerkershelm”** van een torch + steel die licht geeft (lijkt op deze), of een **speed boots** (laarzen die je sneller laten lopen). Voor het laatste zou je bij on_use de speler snelheid physics_override kunnen verhogen zolang het actief is, vergelijkbaar met hoe we de helm activeerden.
5. **Combineer met eerdere mods:** Draag je dirt-helm terwijl je de vliegen-potion gebruikt en ’s nachts door de lucht vliegt – als het goed is, verlicht je als een vallende ster de omgeving! Of zet de helm op en gebruik de feather fall potion in een donkere grot om langzaam neer te dalen met licht. Zie je hoe de verschillende mods elkaar aanvullen?

Super! Je hebt nu een mod gemaakt die een nieuw item (helm) en een nieuw node (licht) toevoegt en deze laat samenwerken. Dit was een wat ingewikkelder voorbeeld, maar hopelijk vond je het leuk om te zien hoe je creatief de spelwereld kunt manipuleren. In het volgende hoofdstuk gaan we door met armor-ideeën: we maken een gravel armor dat je immuun maakt voor schade.

---

## Hoofdstuk 6: Gravel-armor voor onschendbaarheid

**Wat ga je leren?** In dit hoofdstuk maken we weer een stukje “armor” – dit keer een harnas van gravel dat je immuun maakt voor schade. Dat betekent dat als je dit pantser draagt, vijanden je niet kunnen verwonden (en idealiter val- of laverschade ook niet werkt). We bouwen voort op de vorige aanpak (een item dat je activeert om een effect te toggelen). Het nieuwe dat je leert is hoe je de *schadegroepen* van de speler kunt aanpassen, zodat hij/zij geen schade meer krijgt. Ook hier komt een craft en test aan bod, met wat oefeningen.

### Modstructuur

Maak een nieuwe mod map `gravel_armor`. In feite lijkt het op de dirt_armor structuur, maar we hebben geen speciale node nodig deze keer, alleen het item:

```plaintext
gravel_armor/
├── init.lua
├── mod.conf
└── textures/
    └── gravel_chestplate.png   (icoon voor het gravel pantser)
```

In `mod.conf`:
```ini
name = gravel_armor
depends = default
```

Teken een icoontje voor een borstpantser van steentjes (gravel). Je kunt bijvoorbeeld de standaard gravel-textuur als basis nemen en er de vorm van een harnas in aangeven. Of gebruik je fantasie (een grijze vest-achtige vorm). Als je niet tekent, kun je altijd een placeholder nemen (bijv. `"default_stone.png"` als beeld – al klopt dat niet echt met gravel, maar goed).

### Code: pantser dat schade negeert

Open `init.lua` van `gravel_armor` en schrijf deze code:

```lua
-- Tabel om bij te houden bij welke spelers het gravel pantser actief is
local armor_active = {}

-- Registreer het gravel chestplate item
minetest.register_craftitem("gravel_armor:chestplate", {
    description = "Gravel Pantser (onschendbaar)",
    inventory_image = "gravel_chestplate.png",
    on_use = function(itemstack, user, pointed_thing)
        local player = user
        if not player or not player:is_player() then
            return itemstack
        end
        local name = player:get_player_name()
        if armor_active[name] then
            -- Pantser was aan, nu uitzetten
            armor_active[name] = nil
            -- Zet speler terug naar normale kwetsbaarheid
            player:set_armor_groups({fleshy = 100})
            minetest.chat_send_player(name, "Je doet het gravel pantser uit. (Je bent niet langer onschendbaar.)")
        else
            -- Pantser stond uit, nu aandoen
            armor_active[name] = true
            -- Zet speler's armor group zo dat hij geen schade krijgt
            player:set_armor_groups({fleshy = 0})
            minetest.chat_send_player(name, "Je trekt het gravel pantser aan. (Je bent nu immuun voor schade!)")
        end
        return itemstack
    end
})
```

En voeg ook weer een craftrecept toe, bijvoorbeeld in de vorm van een harnas (borstpantser):

```lua
-- Recept: Gravel pantser (borstvorm - 8 stuks gravel)
minetest.register_craft({
    output = "gravel_armor:chestplate",
    recipe = {
        {"default:gravel", "", "default:gravel"},
        {"default:gravel", "default:gravel", "default:gravel"},
        {"default:gravel", "default:gravel", "default:gravel"}
    }
})
```

Uitleg van de code:
- We hebben een tabel `armor_active` om bij te houden welke spelers het pantser effect aan hebben, net zoals bij de helm.
- We registreren een item `gravel_armor:chestplate` met een beschrijving en plaatje.
- In `on_use`, als de speler het pantser gebruikt (rechtermuisknop), kijken we of hij al actief is.
  - Zo ja (pantser uitdoen): we halen de speler uit de tabel en zetten de *armor group* terug naar normaal: `player:set_armor_groups({fleshy = 100})`. In Minetest heeft de groep “fleshy” betrekking op levende wezens (inclusief de speler). Standaard is dat 100, wat betekent 100% schade ontvangen. 
  - Zo nee (pantser aandoen): we markeren active = true en zetten `player:set_armor_groups({fleshy = 0})`. Hiermee wordt de speler effectief onkwetsbaar voor normale schade, want alle inkomende schade op de fleshy-groep wordt met factor 0% vermenigvuldigd (0 dus).
- We sturen telkens een chatbericht zodat de speler weet wat de status is.
- Het recept voor het pantser gebruikt 8 stukken gravel in een vorm die lijkt op een borstpantser (bovenste midden leeg, de rest gevuld), vergelijkbaar met Minecraft recept voor chestplate.

### Testen in Minetest

1. **Mod activeren:** Voeg `gravel_armor` toe en activeer in de wereld.
2. **Pantser craften:** Verzamel 8 gravel blokken (die vind je door grijze grindblokken te hakken, vaak bij water of in grotten). In de crafting grid plaats je ze:
   - Rij 1: [gravel][leeg][gravel]
   - Rij 2: [gravel][gravel][gravel]
   - Rij 3: [gravel][gravel][gravel]
   Dit geeft het Gravel Pantser.
3. **Pantser aandoen:** Zorg dat je niet in creative mode bent (want in creative krijg je sowieso geen schade). Doe het pantser in de hand en klik rechts. Je ziet een melding dat je immuun bent voor schade.
4. **Test onschendbaarheid:** Dit is leuk om te testen met bijvoorbeeld vallen of een andere bron van schade:
   - **Valtest:** Klim een eindje omhoog (10+ blokken) en spring naar beneden. Normaal zou je nu flinke schade krijgen of doodgaan. Met pantser aan zou je (bijna) geen hartjes verliezen. Merk je verschil? Waarschijnlijk blijf je op volle HP.
   - **Lava test (wees voorzichtig):** Als je lava in de wereld hebt, kun je proberen er even in te stappen. Met pantser zou je geen of minimaal schade moeten krijgen (lava schade is iets anders dan fysiek, maar meestal valt ook onder fleshy geloof ik). Doe dit niet te lang of buiten creative, anders kun je alsnog overlijden als iets toch door komt.
   - **Mobs/PvP test:** Als je een monster-mod of een tweede speler beschikbaar hebt, laat ze je slaan. Normaal doet dat pijn, maar met pantser aan zou je geen hartjes verliezen.
5. **Pantser uitdoen:** Klik nogmaals rechts met het item. Je krijgt bericht dat je niet langer onschendbaar bent. Probeer nu nogmaals van hoogte te vallen (maar misschien niet té hoog 😉) en zie dat je nu weer wel schade oploopt.

**Let op:** Dit pantser maakt je niet immuun voor alle mogelijke soorten schade. Het verandert de “fleshy” (levende) schade. Dit dekt slagen, vallen grotendeels en veel mob-aanvallen. Er zijn schades die misschien anders werken (zoals verstikking, vallen in de leegte, of speciale mods met eigen schade). Maar in algemeen survival-gebruik ben je nu heel moeilijk kapot te krijgen. 

Ook is dit pantser in/uit zetten iets wat de speler handmatig doet. In een echte game zou je misschien willen dat zolang het item in een speciale “wear” slot zit het effect heeft. Dat vereist een echt armor-systeem mod. Onze benadering is simpel maar effectief voor demonstratie.

### Verwijzing naar documentatie

Belangrijke trefwoorden uit deze code om op te zoeken: **`set_armor_groups`** en specifiek hoe de “fleshy” group werkt. De waarde 0 betekent geen schade, 100 normaal, >100 betekent extra kwetsbaar, <100 maar >0 betekent verminderd maar niet nul. Je kunt hierover meer lezen bij de Object eigenschappen of player object in de API docs. Zoek bijvoorbeeld op *Minetest player set_armor_groups fleshy* om wat discussies en uitleg te vinden. 

### Oefeningen

Speel weer met de code en bedenk nieuwe dingen:

1. **Half damage:** In plaats van volledig immuun (0), stel `fleshy = 50` in bij aantrekken. Dan krijg je 50% schade. Test dat eens: val van een bepaalde hoogte met pantser uit, zie hoeveel harten eraf gaan, en val van dezelfde hoogte met pantser aan (50) en kijk of het ongeveer de helft is. Interessant om mee te experimenteren.
2. **Auto-uitschakelen (gevorderd):** Zou je de mod zo kunnen aanpassen dat het pantser na een tijdje vanzelf uitgaat? Bijvoorbeeld na 30 seconden onkwetsbaarheid dat het effect stopt (misschien om het niet te sterk te maken). Je zou conceptueel iets met `minetest.after` kunnen doen wanneer iemand het aandoet, dat na X seconden weer fleshy=100 zet voor die speler en `armor_active[name] = nil`. Probeer dit te bedenken of implementeren.
3. **Indicator op HUD (zeer moeilijk):** Als extra uitdaging voor later: je zou bv. een HUD-icoontje kunnen tonen zolang pantser actief is (een schild-icoon op het scherm). Dat kennis bouwt voort op wat we in hoofdstuk 8 gaan doen, maar bedenk het vast als concept.
4. **Nieuw pantseridee:** Maak op dezelfde manier een ander soort pantser met een ander effect. Bijvoorbeeld **“lava armor”** dat je immuun maakt voor vuur/lava (maar dat vereist wellicht ook de “hot” damage group). Of **“water armor”** dat ervoor zorgt dat je onder water niet verdrinkt (dat is weer iets met breath misschien). Sommige dingen zijn moeilijker, maar je kunt creatief nadenken wat je met `player:set_properties` of andere functies zou kunnen aanpassen.
5. **Test in multiplayer:** (Hiervoor heb je een vriend nodig of je moet twee Minetest instances draaien.) Laat de ene speler het pantser dragen en kijk of de andere speler hem/haar geen schade kan doen in PvP. Dat is een leuke manier om je mod in actie te zien met twee mensen. Dit sluit ook mooi aan op hoofdstuk 9 straks.

Goed bezig! Je hebt nu geleerd hoe je de eigenschappen van een speler (zoals schadeweerstand) kunt aanpassen met een mod. Dit opent de deur naar allerlei “superkracht”-mods. In het volgende hoofdstuk gaan we een heel ander soort item maken: **speciale zwaarden** met gekke effecten bij gebruik. Laten we onze creativiteit daar eens op loslaten!

---

## Hoofdstuk 7: Twee speciale zwaarden maken

**Wat ga je leren?** In dit hoofdstuk gaan we iets stoers maken: **speciale zwaarden** met unieke krachten. We verzinnen twee creatieve voorbeelden van zwaarden en implementeren ze allebei in één mod. Hierdoor leer je hoe je tools (gereedschappen/wapens) registreert, hoe je hun *attack* eigenschappen kunt instellen en vooral hoe je bij gebruik of hit iets speciaals laat gebeuren. We doen twee voorbeelden om te laten zien dat je fantasie de limiet is. De voorbeelden die we gaan maken:
1. Een **Regenboogzwaard** – dit zwaard tovert ieder blok dat je ermee slaat om in een willekeurige kleur wol.
2. Een **Teleportatiezwaard** – dit zwaard teleporteert jou een stukje in de kijkrichting wanneer je het gebruikt.

We laten weer de modstructuur zien, de code voor beide zwaarden, en hoe te testen. Daarna kun je zelf vast nog meer gekke zwaarden bedenken!

### Modstructuur

Maak een mod map `special_swords`. In deze mod maken we twee items (zwaarden), elk met hun eigen texture. Ook kunnen we craft recepten voorzien als je wilt. Structuur:

```plaintext
special_swords/
├── init.lua
├── mod.conf
└── textures/
    ├── rainbow_sword.png        (icoon voor regenboogzwaard)
    └── teleporter_sword.png     (icoon voor teleportatiezwaard)
```

In `mod.conf`:
```ini
name = special_swords
depends = default
```
We depend op default omdat we wellicht default:wool en andere standaard items gebruiken.

Maak twee 16x16 px plaatjes voor de zwaarden. Bijvoorbeeld:
- Regenboogzwaard: je kunt een zwaardvorm tekenen met regenboogstrepen erin.
- Teleportatiezwaard: misschien een paars/blauw zwaard om teleportatie te suggereren.

Als tekenen niet je ding is, kun je ook placeholders gebruiken (bv. neem de default sword icon uit Minetest Game als basis als je die kunt vinden, of maak allemaal een effen kleur). Het gaat om het idee.

### Code: Twee zwaarden met bijzondere krachten

Open `init.lua` in de `special_swords` folder en typ onderstaande code. We registreren twee tools (let op, dit keer geen `craftitem` maar `register_tool`, wat beter past bij wapens). 

```lua
-- Regenboogzwaard: Verandert blokken in willekeurige gekleurde wol bij hit
minetest.register_tool("special_swords:rainbow_sword", {
    description = "Regenboogzwaard",
    inventory_image = "rainbow_sword.png",
    tool_capabilities = {
        full_punch_interval = 1.0,
        damage_groups = {fleshy = 4},  -- doet schade vergelijkbaar met een steel sword
    },
    on_use = function(itemstack, user, pointed_thing)
        if pointed_thing and pointed_thing.type == "node" then
            -- Speler richt op een blok
            local pos = pointed_thing.under
            local node = minetest.get_node(pos)
            if node and node.name ~= "air" then
                -- Lijst van beschikbare kleuren wol in default
                local colors = {"white", "grey", "black", "red", "yellow", "green", "cyan", "blue", "magenta", "orange", "brown", "pink", "dark_grey", "dark_green"}
                local rand_color = colors[ math.random(#colors) ]
                -- Verander het blok in een gekleurd wol blok
                minetest.set_node(pos, {name = "wool:" .. rand_color})
            end
        end
        return itemstack
    end
})

-- Teleportatiezwaard: Teleporteert de speler een stukje in de kijkrichting bij gebruik
minetest.register_tool("special_swords:teleporter_sword", {
    description = "Teleportatiezwaard",
    inventory_image = "teleporter_sword.png",
    tool_capabilities = {
        full_punch_interval = 1.2,
        damage_groups = {fleshy = 6},  -- iets sterker basis schade
    },
    on_use = function(itemstack, user, pointed_thing)
        local player = user
        if player then
            -- Bepaal kijkrichting en teleport speler 10 blokken die kant op
            local dir = player:get_look_dir()   -- genormaliseerde richting vector
            local pos = player:get_pos()
            -- Teleporteer naar nieuwe positie: huidige pos + 10 * richting vector
            local newpos = {
                x = pos.x + dir.x * 10,
                y = pos.y + dir.y * 10,
                z = pos.z + dir.z * 10
            }
            -- Controle: we willen niet binnenin een blok teleporteren als het kan
            local node = minetest.get_node(newpos)
            if node.name ~= "air" then
                -- Als doelpositie niet leeg is, verhoog Y totdat leeg (simpel uitweg)
                while node.name ~= "air" and newpos.y < pos.y + 20 do
                    newpos.y = newpos.y + 1
                    node = minetest.get_node(newpos)
                end
            end
            player:set_pos(newpos)
        end
        return itemstack
    end
})
```

Laten we de code in woorden uitleggen:
- **Regenboogzwaard** (`special_swords:rainbow_sword`):
  - `register_tool` lijkt op register_craftitem maar is bedoeld voor gereedschappen/wapens. We geven `tool_capabilities` mee, zodat het zwaard schade kan doen als een normaal zwaard. `damage_groups = {fleshy = 4}` betekent 4 hitpoints schade (2 hartjes) aan spelers/mobs. `full_punch_interval` is hoe snel je achter elkaar kunt slaan (1.0 seconde hier).
  - `on_use` wordt aangeroepen bij rechtsklik (of linkerklik op niks) met het item. We checken `pointed_thing`: dit geeft info over wat de speler richt bij gebruik. We kijken of `pointed_thing.type == "node"`, d.w.z. de speler richt op een blok in de wereld.
  - `pointed_thing.under` is de positie van het blok dat aangeklikt/bekeken wordt. We halen de node daar.
  - Als het geen lucht is (dus er is een blok), dan bepalen we een willekeurige kleur uit een lijst van wol-kleuren (alle kleuren die in default:wool mod zitten).
  - Met `minetest.set_node(pos, {name = "wool:kleurnaam"})` veranderen we dat blok in een gekleurd wolblok.
  - Gevolg: als je met het regenboogzwaard op een blok slaat (rechtermuisknop in dit geval), tover je dat blok om in een vrolijk gekleurd wolletje! 🌈 (Opmerking: We hebben het hier op on_use gezet zodat je niet per ongeluk de hele wereld in wol verandert als je probeert blokken te hakken. Je moet dus bewust rechtsklikken. In survival zul je met links slaan om een blok te hakken, dat zou ook door de engine gebeuren maar we onderscheppen het niet. Rechtsklik is meer “gebruik speciaal”.)
- **Teleportatiezwaard** (`special_swords:teleporter_sword`):
  - Ook hier een register_tool met wat hogere damage (6 = 3 hartjes, bijv. als een diamant zwaard).
  - In `on_use`, ongeacht waar je op mikt (mag ook de lucht zijn), pakken we de speler en bepalen de kijkrichting met `get_look_dir()`. Dat geeft een richtingvector (x,y,z) waarvan de lengte 1 is.
  - We pakken de huidige positie van de speler en voegen de richting maal 10 eraan toe om een positie 10 blokken verder in die richting te krijgen. Dus als je naar voren kijkt en gebruik, dan ga je 10 meter vooruit. Kijk je omhoog, ga je diagonaal omhoog, etc.
  - We doen een kleine check: als de plek waar je uitkomt niet in de lucht is (`~= "air"`), verhogen we de `newpos.y` stapsgewijs tot we boven het obstakel zijn (of tot max 20 blokken hoger dan start). Dit om te voorkomen dat je in een berg of muur vast komt te zitten. (Het is simpel gehouden – er zijn betere manieren zoals raycast, maar dat is gevorderd.)
  - Daarna zetten we de spelerpositie naar newpos met `player:set_pos(newpos)`. Bam, je bent geteleporteerd!
  - Noot: We doen dit op on_use (rechterklik). Linksklikken met dit zwaard zal gewoon schade doen aan mobs/spelers via de normale melee (damage_groups), zonder teleporteffect. Dus je kunt zowel vechten met het zwaard als jezelf verplaatsen met rechtsklik.

Nu nog optioneel: craft recepten voor deze zwaarden. Dit kun je verzinnen – bijvoorbeeld:
- Regenboogzwaard craften uit 1 staal zwaard + 3 verschillend gekleurde wolblokken?
- Teleportatiezwaard craften uit 1 mese kristal + 1 staal zwaard?

We doen even eenvoudige recepten:
```lua
-- Recepten voor de speciale zwaarden
minetest.register_craft({
    output = "special_swords:rainbow_sword",
    recipe = {
        {"", "wool:red", ""},
        {"wool:blue", "default:sword_steel", "wool:green"},
        {"", "wool:yellow", ""}
    }
})
minetest.register_craft({
    output = "special_swords:teleporter_sword",
    recipe = {
        {"", "default:mese_crystal", ""},
        {"", "default:sword_steel", ""},
        {"", "default:diamond", ""}
    }
})
```

Hier stellen we voor:
- Regenboogzwaard: een staalzwaard omringd door 4 gekleurde wol (rood, blauw, groen, geel in een ruitvorm).
- Teleportatiezwaard: een staalzwaard onder een mese crystal en boven een diamant (want magisch en waardevol 😃).

### Testen in Minetest

1. **Mod activeren:** Voeg `special_swords` toe aan mods en activeer in de wereld.
2. **Zwaarden craften of verkrijgen:** Als je de benodigde spullen hebt, kun je de recepten volgen:
   - Regenboogzwaard: je hebt een staalzwaard (iron sword), en rode, blauwe, groene, gele wol nodig. (Wol kun je krijgen via de dye mod of door schapen als je mobs hebt, maar je kunt ook creative mode inschakelen om het te testen makkelijk.)
   - Teleportatiezwaard: je hebt een staalzwaard, een mese kristal en een diamant nodig.
   *Tip:* Je mag gerust in creative mode de items gewoon uit de menu halen om te testen als het verzamelen teveel werk is. Zoek op "Regenboogzwaard" en "Teleportatiezwaard" in de itemlijst. Of gebruik `/give` commando: `/give naam special_swords:rainbow_sword`.
3. **Regenboogzwaard uitproberen:** Neem het regenboogzwaard in de hand. Zoek een plek met allerlei soorten blokken. Klik met rechts op bijvoorbeeld een grasblok, een steen, een boomstam, etc. Je zult zien dat het blok waar je op klikt **verandert in een random kleur wol**! Probeer het een paar keer op dezelfde plek en je ziet verschillende kleuren verschijnen. Het werkt op vrijwel elk blok (pas wel op: het verandert ook kisten of machines als die gewoon blokken zijn – dus niet op je opslag klikken 😅). Dit zwaard doet dus geen speciale particles ofzo, maar de wereld inkleuren is al leuk.
4. **Teleportatiezwaard uitproberen:** Neem het teleportatiezwaard in de hand. Kijk in een bepaalde richting (bijv. op de grond ver voor je, of naar de horizon) en klik rechts. Je zou plots 10 blokken verderop moeten staan! Het voelt alsof je flitst/warpt. Kijk omhoog en gebruik – je gaat omhoog (en valt daarna weer naar beneden tenzij je snel opnieuw gebruikt of de feather fall potion gebruikt 😉). Kijk naar een muur en gebruik: als onze code werkt, zou je bovenop de muur belanden in plaats van er middenin. Speel hiermee rond: je kunt je als nachtcrawler teleporteren over korte afstanden.
5. **Combat testen:** Beide zwaarden hebben ook schade. Je kunt in survival proberen een dier of monster te slaan met links: regenboogzwaard doet normale schade (maar *ook* zal het de blokken die je aanklikt met rechts veranderen, grappig effect als je een mod hebt waar monsters blokken neerzetten ofzo, maar dat is uitzonderlijk). Teleportatiezwaard doet iets meer schade. Test in creatieve scenario’s of met vrienden (zie hoofdstuk 9) hoe het is om deze zwaarden te gebruiken in gevecht. Misschien kun je een vriendje verassen door snel weg te teleporteren als hij je aanvalt!
6. **Gek combinaties:** Probeer eens het regenboogzwaard op verschillende structuren: verander een huis in regenboog-wol! Of spring een ravijn in en teleporteer halverwege naar de zijkant met het teleport-sword.

### Verwijzing naar documentatie

Enkele API onderwerpen die hier gebruikt zijn:
- **`minetest.register_tool`** – zoek hierop om te lezen over tool_capabilities (er zijn ook meer instellingen zoals gebruiksslijtage etc., die we nu niet deden).
- **`pointed_thing`** – dit is een belangrijk concept. Zoek op *Minetest pointed_thing* om te zien hoe het werkt bij on_use en on_punch.
- **`minetest.get_look_dir`** en vectorberekeningen: Als je dit verder wilt uitbouwen, lees over *ObjectRef:get_look_dir()* en ook *minetest.raycast* (voor geavanceerde teleport-checking).
- **Wol kleuren**: We gebruikten namen uit default wool mod. Je kunt op de Minetest wiki de lijst van kleurnamen vinden als je wilt uitbreiden (we hebben de meesten).
- **`minetest.set_node`** weer even, dat kwam eerder ook voor.

### Oefeningen

Nu ben jij de smid van legendarische zwaarden! Probeer:

1. **Verander de wolkleuren:** Pas de lijst van kleuren aan. Voeg er bijvoorbeeld “violet” of “dark_blue” aan toe (als die bestaan in wool mod). Of laat het zwaard niet in *alle* kleuren kunnen veranderen maar kies uit een paar specifieke (bijv. alleen warme kleuren).
2. **Teleport afstand variëren:** Wij kozen 10 blokken. Verander dat naar 5 of 20 en test. Pas ook de `while` check aan als je veel verder gaat, zodat je niet alsnog in een berg komt vast te zitten.
3. **Nieuw speciaal zwaard bedenken:** Gebruik deze twee als voorbeeld en verzin je eigen:
   - Bijvoorbeeld een **Vuurzwaard** dat elke mob of speler die je raakt in brand steekt (hint: je zou in `on_use` of misschien beter `on_secondary_use` een fire node op de plek van het slachtoffer kunnen plaatsen of hun HP reduceren over tijd).
   - Of een **Explosiezwaard** dat bij impact een kleine explosie veroorzaakt (hint: `tnt.boom()` functie als de TNT mod actief is, of spawn een `fire:basic_flame` en `minetest.sound_play("explosion")`).
   - Misschien een **Summonzwaard** dat een dier of monster spawnt waar je mee slaat (vereist een mobs mod).
   - Of iets milders, een **Hamer van groei** die elke zaailing waar je op slaat in een boom verandert (je kunt een sapling vervangen door een fully grown tree using schematics misschien).
   Laat je fantasie gaan! Begin simpel: kopieer de structuur van on_use van een van onze zwaarden en pas de actie aan.
4. **Balans de recepten:** Denk na of de door ons gegeven craftrecepten eerlijk zijn voor wat het zwaard kan. Misschien zou regenboogzwaard duurder of juist goedkoper moeten, idem voor teleporter. Pas de recepten aan en bedenk waarom (goed argumenteren is ook belangrijk bij game design!).
5. **Combineer met andere mods:** Gebruik het regenboogzwaard terwijl je de dirt-helm draagt in een donkere grot: je verlicht de grot én schildert hem tegelijk! Of gebruik teleport-sword om supersnel verticale afstanden te overbruggen in combinatie met de feather fall potion, zodat je zacht landt na een hoge teleport. Dit is het leuke aan mods – jullie creaties werken samen.

Gefeliciteerd, je hebt nu behoorlijk complexe items gemaakt! Hiermee heb je veel aspecten van modding geraakt: nieuwe items, blokken, effecten op de wereld en op spelers. In het volgende hoofdstuk gaan we nog iets heel anders doen: geen nieuwe items, maar de gebruikersinterface (HUD) aanpassen om een eigen statistiek weer te geven. Klaar om de HUD te hacken?

---

## Hoofdstuk 8: Een eigen HUD-statistiek toevoegen (Strength)

**Wat ga je leren?** In dit hoofdstuk kijken we naar de HUD (Heads-Up Display) – de informatie op het scherm, zoals harten, lucht, hotbar, etc. We gaan een eenvoudige eigen HUD-element toevoegen: een tekst die een waarde “Strength” (kracht) aangeeft. Daarnaast maken we een item (bijvoorbeeld een halter/dumbbell) waarmee de speler zijn Strength kan verhogen. Zo zie je hoe je dynamisch de HUD kunt updaten. Dit leert je hoe je iets op het scherm tekent via code, en hoe je data per speler kunt bijhouden.

### Modstructuur

Maak een mod map `hud_strength`. In deze mod hebben we één init.lua en een texture voor onze dumbbell:

```plaintext
hud_strength/
├── init.lua
├── mod.conf
└── textures/
    └── dumbbell.png    (icoon voor de halter)
```

In `mod.conf`:
```ini
name = hud_strength
depends = default
```
(Mogelijk is default niet eens nodig hier, maar kan geen kwaad. Als we appels of staal gebruiken voor craft, is default nodig.)

Maak een klein plaatje `dumbbell.png` – bijvoorbeeld twee zwarte gewichten met een stang (denk aan een halter). Heel simpel kan het ook een grijse staaf zijn. Dit wordt het inventory icoon voor onze halter.

### Code: HUD element en dumbbell item

Open `init.lua` in `hud_strength` en schrijf de code:

```lua
-- Houd bij per speler: strength waarde en HUD id
local player_strength = {}
local strength_hud_id = {}

-- Wanneer een speler joint, initialiseer de strength en HUD
minetest.register_on_joinplayer(function(player)
    local name = player:get_player_name()
    -- Beginwaarde Strength
    player_strength[name] = 0
    -- Voeg HUD element toe voor de strength waarde
    strength_hud_id[name] = player:hud_add({
        hud_elem_type = "text",
        position  = {x=0.5, y=0.0},
        offset    = {x=0,   y=20},
        alignment = {x=0,   y=1},
        scale     = {x=100, y=100},  -- schaal van de tekst
        text      = "Strength: 0",
        number    = 0xFFFFFF,       -- witte tekst
    })
end)

-- Registreer een "halter" item om strength te verhogen
minetest.register_craftitem("hud_strength:dumbbell", {
    description = "Halter (verhoogt Strength)",
    inventory_image = "dumbbell.png",
    on_use = function(itemstack, user, pointed_thing)
        local player = user
        if player then
            local name = player:get_player_name()
            -- Verhoog de strength waarde
            player_strength[name] = (player_strength[name] or 0) + 1
            -- Pas de HUD tekst aan
            local new_text = "Strength: " .. player_strength[name]
            player:hud_change(strength_hud_id[name], "text", new_text)
            -- Misschien een leuk geluid of effect toevoegen (optioneel)
        end
        return itemstack
    end
})

-- Voeg een recept toe voor de halter: (staaf van een stok en gewichten van staal?)
minetest.register_craft({
    output = "hud_strength:dumbbell",
    recipe = {
        {"default:steel_ingot"},
        {"default:stick"},
        {"default:steel_ingot"}
    }
})
```

Uitgelegd:
- We hebben twee tabellen: `player_strength` om de actuele sterkte per spelernaam op te slaan, en `strength_hud_id` om het ID van het HUD element op te slaan zodat we het later kunnen updaten.
- `register_on_joinplayer`: zodra een speler de wereld betreedt:
  - We zetten hun strength op 0 in onze tabel.
  - We voegen een HUD element toe met `player:hud_add({...})`. We kiezen `hud_elem_type = "text"` om tekst weer te geven. We plaatsen het element met `position = {x=0.5, y=0.0}` wat betekent middenboven aan het scherm (x=0.5 is horizontaal midden, y=0.0 is top). De `offset = {x=0, y=20}` duwt het iets naar beneden vanaf de bovenrand zodat het niet helemaal in de hoek plakt.
  - `alignment = {x=0, y=1}` zorgt dat de tekst gecentreerd wordt (x=0) en naar beneden gaat (y=1). Scale en offset zijn een beetje uitproberen; hier gebruiken we {100,100} zodat het een normale grootte heeft.
  - De tekst beginnen we als "Strength: 0". `number = 0xFFFFFF` kleurt de tekst wit (hexadecimaal voor RRGGBB).
  - `hud_add` geeft een id terug (integer) dat dat HUD element representeert. We slaan dat op in `strength_hud_id[name]`.
- We registreren een item `dumbbell` (halter). In `on_use`:
  - We verhogen de strength in onze tabel voor de speler met +1.
  - We bouwen een nieuwe tekststring "Strength: X" met de bijgewerkte waarde.
  - Met `player:hud_change(strength_hud_id[name], "text", new_text)` veranderen we de bestaande HUD tekst naar de nieuwe waarde. Zo ziet de speler zijn Strength getal oplopen.
  - We laten het item niet verbruiken (`return itemstack` zonder itemstack:take_item), zodat je de halter eindeloos kunt gebruiken om te trainen.
  - (Je zou eventueel een limiet kunnen zetten of een cooldown, maar voor nu niet.)
- Craftrecept: 1 steel ingot boven, 1 stick midden, 1 steel ingot onder – dit stelt een halter voor (de stang is de stick, de gewichten zijn de stalen schijven).

### Testen in Minetest

1. **Mod activeren:** Voeg `hud_strength` mod toe en activeer in de wereld.
2. **Bij het joinen:** Zodra je de wereld betreedt met je speler, zou je bovenin het scherm de tekst **Strength: 0** moeten zien staan (mogelijk half bovenin gecentreerd). Dit is jouw HUD element dat onze mod toevoegt.
3. **Halter verkrijgen:** Craft de halter met het recept (2 staal + 1 stok) of pak hem via creative. In creative kun je het icoon zoeken (halter) en eruit pakken.
4. **Train je Strength:** Houd de halter vast en klik rechts (alsof je hem gebruikt). Je zou een paar keer achter elkaar de halter “liften”. Iedere keer dat je dat doet, kijk naar de tekst: **Strength: 1**, dan **Strength: 2**, dan **Strength: 3**, ... enz. Het getal neemt toe met elke use. Gefeliciteerd, je hebt een werkende strength counter!
5. **Multiplayer check (indien mogelijk):** Als je een tweede speler laat joinen (bijvoorbeeld via LAN of een tweede client), zal die ook een eigen Strength teller hebben, onafhankelijk. Als speler2 de halter gebruikt, zal alleen zijn/haar eigen Strength getal stijgen op diens scherm. Jouw teller blijft gelijk. Dit komt doordat we de values opslaan per naam en HUD per speler. (Je kunt dit wellicht testen in singleplayer moeilijk, maar vertrouw erop dat het per speler gaat.)
6. **Opslaan bij leave (opmerking):** In deze simpele versie reset Strength iedere keer je opnieuw joint (we zetten bij join op 0). Als je wilt, kun je proberen dat persistent te maken (dat is lastiger: je zou player meta moeten opslaan tussen sessies). Maar dat laten we nu zo; elke speelsessie train je opnieuw.
7. **Leuke aankleding:** Je zou bij het gebruik een geluid kunnen afspelen (bijv. een “uff” geluid) of een chatbericht “Poeh! Strength is nu X”. Dat hebben we niet gedaan, maar je kunt zelf toevoegen als oefening.

### Verwijzing naar documentatie

Dit hoofdstuk raakt aan:
- **HUD API**: zoek op *Minetest hud_add hud_change hud_remove* in de docs voor meer details. Er zijn ook hud_elem_types voor images, bars, etc.
- **Player meta**: als je wilt dat Strength bewaard blijft per speler tussen sessies, kun je `player:set_meta("strength", waarde)` gebruiken en bij join `player:get_meta():get...`. Dit is wat geavanceerder (in de API docs onder ObjectRef metadata).
- **register_on_joinplayer** en ook eventueel **register_on_leaveplayer** (we hebben leave niet gebruikt, maar handig om op te ruimen als het nodig was).
- **Craftitem on_use**: we deden dat al eerder bij potions, hier herhaald.

### Oefeningen

Nu kun je dit concept uitbreiden of aanpassen:

1. **Startwaarde aanpassen:** Laat nieuwe spelers misschien met Strength 5 beginnen in plaats van 0, of haal een opgeslagen waarde op als je dat implementeert.
2. **Positie/uiterlijk HUD:** Verplaats de Strength text naar een andere hoek of kleur. Probeer bijvoorbeeld linksboven in het scherm oranje te zetten. (Hint: position {x=0, y=0} is linksboven. number = 0xFF8800 zou een oranje kleur geven.)
3. **Andere HUD element types:** In plaats van tekst kun je ook een afbeelding als HUD elem doen. Bijvoorbeeld, toon een klein icoontje van een gewicht en de waarde ernaast. (Hiervoor kun je twee hud_add doen: één image, één text. Of nog mooier: er is een hud_elem_type "statbar" dat rijtjes van een icoon kan tonen, zoals de hartjes en bubbels doen. Je zou Strength kunnen presenteren als aantal “muscle” icoontjes. Dat is wat complexer, maar kijk in docs bij hud_elem_type.)
4. **Beperk strength:** Misschien wil je niet oneindig opschroeven. Voeg eens een maximum toe: als strength >= 10, laat de hud_change niet verder gaan en geef een bericht “Je hebt het maximum bereikt!”. Dit vergt een simpele if in on_use.
5. **Gebruik Strength ergens voor (verdieping):** Op zich is een stat leuk, maar nog leuker als het invloed heeft. Kun je een manier bedenken om de Strength waarde te laten meespelen in iets? Bijvoorbeeld: je zou kunnen koppelen dat als Strength hoog is, je met de hand harder slaat of sneller graaft. Dat kan door in e.g. register_on_punchplayer event de damage te verhogen afhankelijk van de attacker’s Strength. Of je zou in een globalstep kunnen kijken naar Strength en de player:set_physics_override gebruiken om bij hoge Strength sneller te laten sprinten (kracht = snelheid?). Dit zijn moeilijke uitbreidingen, maar bedenk: een HUD stat kan dienen als basis voor rpg-achtige gameplay.
6. **Persistente opslag (moeilijk):** Probeer de tip over player meta-data: sla de Strength op zodat als je de wereld verlaat en terugkomt, je waarde niet weg is. (Je kunt in `on_leaveplayer` iets doen of direct in hud_change ook `player:get_meta():set_int("strength", player_strength[name])`. En in on_joinplayer lezen `player:get_meta():get_int("strength")` voor de start. Documentatie API “PlayerMetaRef” kan hierbij helpen.)

Je hebt nu geleerd hoe je de interface kunt veranderen en informatie aan de speler tonen. Dit is al behoorlijk gevorderd modden, goed gedaan! 

We hebben bijna alle onderwerpen behandeld die we ons voorgenomen hadden. Er is nog één praktisch onderdeel over: **hoe speel je je mods samen met vrienden via LAN**. Dat komt nu aan bod in het afsluitende hoofdstuk.

---

## Hoofdstuk 9: Samen spelen via Local Area Network (LAN)

**Wat ga je leren?** In dit laatste hoofdstuk leggen we uit hoe je de door jou gemaakte mods kunt gebruiken in een multiplayerspel met anderen op jouw lokale netwerk (bijvoorbeeld thuis met broer/zus, op school met klasgenoten in hetzelfde wifi-netwerk). We beschrijven stap voor stap hoe je een LAN-spel host en laat anderen aansluiten. Het is geen code, maar wel handig om te weten zodat je de pret kunt delen!

### Voorbereidingen

Zorg ervoor dat alle computers die mee willen spelen:
- Op hetzelfde lokale netwerk zitten (bijv. dezelfde wifi of bedraad LAN). 
- Dezelfde versie van Minetest/Luanti geïnstalleerd hebben.
- Jouw mods beschikbaar hebben of in elk geval dat de host ze heeft. *(Opmerking: in Minetest is het voldoende dat de server (host) de mods heeft; de clients krijgen automatisch de content. Maar het kan nuttig zijn dat iedereen de mods ook lokaal heeft, vooral als het media-delen traag is.)*

Beslis wie de **host** wordt (degene die de wereld “aanzet” waar anderen op inloggen). Dit is meestal de persoon die de wereld met de mods al heeft, bijvoorbeeld jijzelf als maker.

### Wereld instellen en hosten

Volg deze stappen op de host-computer:

1. **Open Minetest en selecteer de wereld** die je wilt gebruiken voor multiplayer. Dit kan een bestaande wereld zijn waar je mods al op actief zijn, of je maakt een nieuwe wereld en activeert de gewenste mods daarop.
2. In het hoofdmenu, ga naar het tabblad *Start Game*. Kies je wereld.
3. Aan de linkerkant zie je opties zoals *Creative Mode* en *Enable Damage*. Zorg dat deze naar wens staan (wil je creatieve mode aan of uit? damage aan voor survival?).
4. Heel belangrijk: vink het hokje **Host Server** aan. Dit zorgt ervoor dat wanneer je de wereld start, het als multiplayer server draait.
5. Kies een **spelersnaam** en **wachtwoord** voor jezelf als host, als je dat nog niet had. (Als je altijd Singleplayer speelde, let op: voor multiplayer kun je beter even een naam instellen in het Settings menu -> Client -> naam, of direct hier invullen. Het wachtwoord is om jouw speler te beveiligen zodat een ander op het netwerk niet onder jouw naam binnenkomt.)
6. Klik nu op **Play Game** (Spel Starten). De wereld wordt geladen. Jij bevindt je nu in de wereld als host en de server luistert naar inkomende verbindi ([File:Minetest Game Main Menu.png - Wikimedia Commons](https://commons.wikimedia.org/wiki/File:Minetest_Game_Main_Menu.png))_image】 *Afbeelding: Het hoofdmenu van Minetest/Luanti. Om een LAN-server te starten selecteer je een wereld en vink je "Host Server" aan voordat je op "Play Game" klikt. Andere spelers gebruiken het "Join Game" tabblad om aan te sluiten.*

Wanneer het spel geladen is, zie je in je chat misschien een bericht zoals “Server running at 0.0.0.0:30000” of in de terminal/log iets van “Listening on port 30000”. Dit betekent dat de server draait. 

### Laten aansluiten (joinen) via LAN

Nu laat je de andere spelers verbinden:

1. De andere spelers starten Minetest op hun eigen computer.
2. In het hoofdmenu gaan ze naar het tabblad **Join Game** (Multiplayer).
3. Laat ze een spelersnaam invullen en een wachtwoord verzinnen. (Iedere speler moet een unieke naam hebben – dus niet allemaal “Player” want dat botst. Bijvoorbeeld gebruik jullie eigen voornamen of bijnamen.)
4. Ze moeten nu het adres en poort van de server invoeren. Omdat jullie in hetzelfde lokale netwerk zitten, is dit het LAN-IP-adres van de hostcomputer en de poort (standaard 30000).
   - De poort is doorgaans **30000** (tenzij je dat in server settings veranderd hebt, maar standaard is 30000 goed).
   - Het IP-adres van de host kun je vinden door op de hostcomputer in de netwerksettings te kijken. Vaak begint een lokaal IP met 192.168.x.x of 10.0.x.x. Bijvoorbeeld 192.168.1.5.
   - Stel jouw host IP is 192.168.1.5, dan vullen de anderen bij *Address* in: `192.168.1.5` en bij *Port*: `30000`.
   - **Tip:** Soms verschijnt de LAN-server automatisch in het Join Game scherm onderin (Minetest kan lokale servers detecteren). Als ze daar een naam zien verschijnen (bijv. “Test Wereld [Minetest]”), kunnen ze die selecteren en de velden vullen zich in.
5. Als de naam, wachtwoord en adres/poort ingevuld zijn, klikken ze op **Connect** (Verbinden).
6. De eerste keer kan het enkele seconden duren, vooral als er custom media (plaatjes van mods) gedownload moeten worden naar de spelers. Wacht geduldig; ze krijgen waarschijnlijk een “Media…” voortgangsbalkje terwijl textures van jouw mods worden binnengehaald. (Daarom is het handig dat jouw texturebestanden klein zijn, wat ze meestal wel zijn, of dat de andere spelers de mod al geïnstalleerd hebben lokaal zodat geen download nodig is.)
7. Als alles goed gaat, verschijnen de andere spelers in jouw wereld! Je zult in jouw game zien “PlayerX joined the game.” En op hun scherm zijn ze nu in de wereld samen met jou.

### Samen mods beleven

Nu spelen jullie lokaal samen in de wereld. Alle mods die jij geactiveerd had in de wereld zijn nu actief voor iedereen. Enkele aandachtspunten/fun dingen:
- **Check mods**: Typ `/mods` in de chat; iedereen zal de lijst van actieve mods zien, waaronder de mods die je zelf gemaakt hebt. Cool hè?
- **Gebruik de mods samen**: Probeer elkaar de items te geven en kijken of ze werken. Bijvoorbeeld:
  - Ruil de vliegen-potion en feather-fall potion uit en test of een ander er ook mee kan vliegen.
  - Doe een PvP gevecht: de één met het regenboogzwaard, de ander met het teleportatiezwaard, of test de gravel armor door elkaar te slaan terwijl die aan staat.
  - Bouw samen iets en gebruik de dirt-helm om het ’s nachts te verlichten voor iedereen.
  - Misschien grappig: iemand met regenboogzwaard verandert blokken terwijl de ander probeert te bouwen, geeft een gek kleurfestijn.
- **LAN stabiel houden**: Zorg dat de host-computer niet te zwaar belast wordt. Als er lag optreedt (vertraging), kan het helpen als niet teveel andere programma’s draaien. Maar over het algemeen kan Minetest wel een paar spelers op een thuisnetwerk aan.
- **Opslaan en stoppen**: Als jullie klaar zijn, kan de host gewoon het spel verlaten (Esc > Save and Exit). De wereld wordt dan opgeslagen met alle veranderingen en iedereen wordt losgekoppeld. Andere spelers kunnen gewoon hun client sluiten of wachten tot “Server shut down” melding komt.
- Volgende keer kan je dezelfde stappen herhalen om verder te spelen.

### Problemen oplossen

- *Kan niet verbinden:* Controleer het IP-adres goed. Het moet het lokale adres van de host zijn, niet bijv. 127.0.0.1 (dat is localhost voor hun eigen PC) en niet een internet IP (wan IP) want jullie zitten op LAN. In Windows kun je `ipconfig` in cmd doen om IPv4 Address te vinden. In Mac/Linux `ifconfig` of kijk in netwerkicoontje details.
- *Firewall:* Soms blokkeert een firewall inkomende verbindingen. Als spelers de host niet kunnen bereiken, check de host’s firewall instellingen. Voeg eventueel een regel toe om Minetest (poort 30000) toe te staan op het lokale netwerk.
- *Versie mismatch:* Zorg dat iedereen dezelfde Minetest/Luanti versie heeft. Verschillende versies kunnen soms niet compatibel zijn als er grote verschillen zijn.
- *Mods niet actief:* Als iets van de mod niet werkt voor anderen, bedenk dat de server de logica runt. De clients krijgen alleen de visuele data. Dus als er toch iets niet werkt, kijk op de server (host) console voor eventuele errors van mods. Debug eventueel je mod.
- *Te veel lag:* In een lokaal netwerk zal lag weinig zijn, behalve als de host-computer het niet aan kan. Verminder grafische settings of beperk aantal actieve mods als het een heel zwakke machine is.

### Oefeningen

Er is hier niet echt code om te veranderen, maar wel dingen om uit te proberen:
1. **Speel scenario’s:** Verzín een speltype met de mods. Bijvoorbeeld een soort mini-game: wie het eerst 10 gekleurde wol-blokken verzamelt door regenboogzwaard te gebruiken, of een PvP wedstrijd waarbij alleen special swords zijn toegestaan.
2. **Coöp bouwen:** Bouw samen een kleurrijk huis en gebruik regenboogzwaard als schilderkwast. Laat iemand anders de kleuren "aanbrengen" terwijl jij blokken plaatst.
3. **Mod debugging in MP:** Provoceer bewust iets geks: wat als twee spelers tegelijk de halter gebruiken? Werkt ieders HUD goed? Wat als een speler de game joint die geen halter heeft en een andere wel hoge strength – ziet diegene zijn eigen 0 zonder issues? Dit soort tests kunnen je inzicht geven in hoe robuust je mod is.
4. **LAN met meer dan lokaal:** Dit gaat buiten LAN, maar als je ooit wilt dat iemand van buiten je netwerk meedoet (bijv. een vriend van verderweg via internet), moet je port-forwarding instellen op je router voor poort 30000. Dat is wat geavanceerder netwerkbeheer en niet altijd veilig; doe dat alleen als je weet wat je doet (en met ouder/toestemming als je jong bent). LAN is meestal makkelijk en veilig genoeg.

---

## Afsluiting

Je hebt het einde van dit leerboek bereikt – fantastisch gedaan! 🎉 We hebben heel veel behandeld:
- Inleiding in mods en een welkomstbericht mod.
- Crafting recepten toegevoegd (dirt -> diamond).
- Magische potions gemaakt om te vliegen en langzaam te vallen.
- Een lichtgevende helm en een onschendbaar pantser geprogrammeerd.
- Twee supercoole speciale zwaarden bedacht en geïmplementeerd.
- Een eigen HUD statistiek uitgeprobeerd.
- Geleerd hoe je alles met vrienden op LAN kunt spelen.

Hopelijk heb je gemerkt dat programmeren in Lua voor Minetest best leuk en goed te doen is, vooral als je stap-voor-stap voorbeelden volgt en vervolgens mee gaat experimenteren. Misschien heb je onderweg al je eigen twists gegeven aan de oefenopdrachten – supergoed! Zo leer je creatief denken als programmeur.

Natuurlijk is er nog véél meer te ontdekken in Minetest modding. Je kunt bijvoorbeeld leren hoe je eigen blokken met modellen of animaties maakt, hoe je vormen (nodes) kunt genereren, hoe je interactieve formspecs (venstertjes) maakt, of zelfs hoe je vijandige mob monsters of vriendelijke dieren kunt toevoegen via Lua. De mogelijkheden zijn eindeloos. 

Belangrijk is dat je plezier houdt in het *doen*: proberen, fouten maken, oplossen, en iets nieuws laten werken. Als iets niet in één keer werkt, niet opgeven! Lees de foutmeldingen, zoek in de documentatie (zoekterm: *Minetest Modding API*), vraag eventueel hulp op forums (de Minetest community is er eentje van behulpzame mensen en mede-modders).

Je bent nu geen gewone speler meer, maar ook een **maker** binnen Minetest. Hoe gaaf is dat? Blijf oefenen en misschien schrijf je over een tijdje wel je eigen complete game-mode of publiceer je mods zodat anderen ze kunnen gebruiken.

Veel succes en vooral veel plezier met programmeren en spelen! 

***Einde van het leerboek***